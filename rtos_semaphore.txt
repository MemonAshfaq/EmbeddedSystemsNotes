===========================================================
RTOS Inter-task Communication - Block 2: SEMAPHORES
===========================================================

What is a Semaphore?
--------------------
- A semaphore is a synchronization tool, not for data transfer.
- Tasks can "take" (wait) and "give" (signal) the semaphore.
- When a task takes it, the count decreases.
- If count is 0, the task blocks until another task/ISR gives it.

Types of Semaphores
-------------------
1. Binary Semaphore:
   - Acts like a flag (0 or 1).
   - Commonly used for ISR → Task signaling.
   - Task blocks until ISR signals.

2. Counting Semaphore:
   - Keeps a count of available resources.
   - Example: managing a pool of N identical devices.
   - Each take reduces count, each give increases count.

Why use Semaphores?
-------------------
- Wake a task when an external event occurs.
- Control access to limited resources.
- Avoid busy waiting → CPU efficient.

FreeRTOS Example: Binary Semaphore (ISR → Task)
------------------------------------------------

SemaphoreHandle_t xBinSem;

void vTask(void *pv) {
    for(;;) {
        // Wait for semaphore to be given
        xSemaphoreTake(xBinSem, portMAX_DELAY);
        printf("Event received! Task running...\n");
    }
}

// Simulated interrupt service routine
void vISR_Handler(void) {
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;

    // Give semaphore from ISR
    xSemaphoreGiveFromISR(xBinSem, &xHigherPriorityTaskWoken);

    // Force context switch if needed
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

int main(void) {
    xBinSem = xSemaphoreCreateBinary();

    xTaskCreate(vTask, "Task", 1000, NULL, 2, NULL);
    vTaskStartScheduler();
}


===========================================================
RTOS Inter-task Communication - Block 2 (extended): SEMAPHORES
===========================================================

Counting Semaphore Example
--------------------------
Use Case:
- Suppose we have 3 identical UART channels.
- Up to 3 tasks can use them at the same time.
- If all 3 are busy, other tasks must wait.

FreeRTOS Example: Counting Semaphore

SemaphoreHandle_t xCountSem;

void vUartTask(void *pv) {
    for(;;) {
        // Try to get one UART channel
        if (xSemaphoreTake(xCountSem, portMAX_DELAY) == pdPASS) {
            printf("Task %s got a UART channel\n", pcTaskGetName(NULL));

            // Simulate UART usage
            vTaskDelay(pdMS_TO_TICKS(200));

            printf("Task %s releasing UART\n", pcTaskGetName(NULL));

            // Release channel back
            xSemaphoreGive(xCountSem);
        }
        vTaskDelay(pdMS_TO_TICKS(100));
    }
}

int main(void) {
    // Create counting semaphore with max count = 3
    // Initial count = 3 (3 UARTs available)
    xCountSem = xSemaphoreCreateCounting(3, 3);

    // Create 5 tasks competing for 3 UART channels
    for (int i = 0; i < 5; i++) {
        char name[10];
        sprintf(name, "Task%d", i);
        xTaskCreate(vUartTask, name, 1000, NULL, 2, NULL);
    }

    vTaskStartScheduler();
}

Explanation:
------------
- At most 3 tasks can hold the semaphore simultaneously.
- When a task takes one, count decreases.
- When count reaches 0, extra tasks block until one is released.
- Ensures fair sharing of limited resources.

Key Points Recap:
-----------------
- Binary Semaphore → event signaling (flag).
- Counting Semaphore → resource pool management.
- Neither provides priority inheritance (use Mutex instead).
===========================================================

Key Points
----------
- Binary semaphore is best for EVENT signaling.
- Counting semaphore is best for managing RESOURCE pools.
- Unlike a mutex, semaphores do NOT provide priority inheritance.
- Use Mutex when protecting critical sections.
===========================================================
